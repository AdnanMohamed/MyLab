// This is the implementation file for the template class set.
// See interface in set.h
//-------- Copyright © ---------
//  @Author: Adnan Hashem Mohamed
//-------------------------------
//
// CLASS INVARIANT:
// 1- The items of the set are stored in a B-tree, satisfying the six B-tree rules.
// 2. The number of entries in the tree’s root is stored in the member variable data_count,
//	  and the number of subtrees of the root is stored in the member variable child_count.
// 3. The root’s entries are stored in data[0] through data[data_count-1].
// 4. If the root has subtrees, then these subtrees are stored in sets pointed to by
//	  the pointers subset[0] through subset[child_count-1].

#include<algorithm>
#include<iostream>
namespace set_adnan{

    template<class Item, class SizeType>
    void shift_right(Item a[], SizeType size, SizeType index)
        // Precondition: size is the size of the array, index is a valid index
        // Postcondition: all elements from index and after it are shifted one spot
        // to the right to make index a valid place to insert an element in.
    {
        for (auto i = size - 1; i > index; --i)
            a[i] = a[i - 1];
    }
	
	template<class Item>
	set<Item>::set()
	{
		data_count = 0;
		child_count = 0;
	}

	template<class Item>
	std::size_t set<Item>::count(const Item& target) const
	{
		// find 'i' such that data[i] >= target
		std::size_t i = 0;
		while((i < data_count) && (data[i] < target))
		{
			++i;
		}

		// now i could be equal to data_count which is out-of-range index
		// or it is the wanted index
		if((i != data_count) && !(target < data[i]))
			return 1;
		else if(child_count <= i)  // no possible child has the target (base on how elements are sorted ascendantly)
			return 0;
		else
			return subset[i]->count(target);	// search the target in the "correct" subtree
	}

	template<class Item>
	void set<Item>::clear()
	{
		for(std::size_t i = 0; i < child_count; ++i)
		{
		  subset[i]->clear();
		}
		for(std::size_t i = 0; i < child_count; ++i)
		  delete subset[i];			
		child_count = 0;
		data_count = 0;
	}

	template<class Item>
	set<Item>::set(const set<Item>& source)
	{
		
		for (size_t i = 0; i < source.child_count; ++i)
			subset[i] = new set<Item>(*(source.subset[i]));
		data_count = source.data_count;
		child_count = source.child_count;
		std::copy(source.data, source.data + data_count, data);
	}

	template<class Item>
	set<Item>& set<Item>::operator =(const set<Item>& source)
	{
		if (this != &source)
		{
			clear();
			for (size_t i = 0; i < source.child_count; ++i)
				subset[i] = new set<Item>(*(source.subset[i]));
			data_count = source.data_count;
			child_count = source.child_count;
			std::copy(source.data, source.data + data_count, data);
		}
		return *this;
	}

	template <class Item> bool set<Item>::loose_insert(const Item& entry)
		// Precondition: The entire B-tree is valid. 
		// Postcondition: If entry was already in the set, then the set is unchanged 
		// and the return value is false. Otherwise, the entry has been added to the 
		// set, the return value is true, and the entire B-tree is still 
		// valid EXCEPT that the number of entries in the root of this set might be 
		// one more than the allowed maximum.
	{
		// find 'i' such that data[i] >= entry
		std::size_t i = 0;
		while ((i < data_count) && (data[i] < entry))
		{
			++i;
		}
		// now i could be equal to data_count which is out-of-range index
		// or it is the wanted index

		// don't change the set if it already has the element.
		if ((i < data_count) && !(entry < data[i]))
			return false;
		else if (is_leaf())
		{
			// shifting the elements right to insert entry.
			shift_right(data, MAXIMUM + 1, i);

			// insert the new entry
			data[i] = entry;
			data_count++; // increment the counter of elements in the node.
			return true;
		}
		else
		{
			bool is_inserted = subset[i]->loose_insert(entry);

			// check if the current node has extra entry, then fix it.
			if (subset[i]->data_count > MAXIMUM)
				fix_excess(i);
			return is_inserted;
		}
	}

	template<class Item>
	bool set<Item>::insert(const Item& entry)
	{
		if (!loose_insert(entry))
			return false;
		if (data_count > MAXIMUM)
		{
			// creating a new child that holds the current b-tree
			set<Item>* new_child = new set<Item>(*this);
			
			// erasing the current root to be empty
			clear();
			
			// giving the root a child which is the previous tree.
			subset[0] = new_child;
			child_count++;
			
			// The 1st child has excess element, fix it.
			fix_excess(0);
		}

		return true;
	}

	template <class Item> 
	void set<Item>::fix_excess(std::size_t i)
	// Precondition: (i < child_count) and the entire B-tree is valid EXCEPT that 
	// subset[i] has MAXIMUM + 1 entries. 
	// Postcondition: The tree has been rearranged so that the entire B-tree is 
	// valid EXCEPT that the number of entries in the root of this set might be 
	// one more than the allowed maximum. 
	{
		// spliting the problamatic node.
		set<Item>* left_set = new set<Item>;
		set<Item>* right_set = new set<Item>;
		std::copy(subset[i]->data, subset[i]->data + MINIMUM, left_set->data);
		std::copy(subset[i]->data + MINIMUM + 1, subset[i]->data+ MAXIMUM + 1, right_set->data);
		left_set->data_count = MINIMUM; // The new left and right split sets are of have MINIMUM 
		right_set->data_count = MINIMUM; // elements in the root.
		
		// equally giving each set its children.
		if (!subset[i] -> is_leaf())
		{
			for (size_t j = 0; j < (MAXIMUM) / 2 + 1; ++j)
				left_set->subset[j] = new set<Item>(*(subset[i]->subset[j]));
			for (size_t k = 0, j = (MAXIMUM) / 2 + 1; j < (MAXIMUM)+2; ++k, ++j)
				right_set->subset[k] = new set<Item>(*(subset[i]->subset[j]));
		}

		
		left_set->child_count = (subset[i]->child_count) / 2;
		right_set->child_count = (subset[i]->child_count) / 2;

		// passing the middle entry of the excess node's root to its parent
		if (data_count > 0)
		{
			shift_right(data, MAXIMUM + 1, i);
			data[i] = subset[i]->data[MINIMUM];
		}
		else
		{
			data[0] = subset[i]->data[MINIMUM];
		}
		data_count++;

		// fixing the parent's children.
		shift_right(subset, MAXIMUM + 2, i + 1);
		subset[i]->clear();
		subset[i] = left_set;
		subset[i + 1] = right_set;
		child_count++;
	}

	template<class Item>
	std::size_t set<Item>::size()const
	{
		auto sum = data_count;
		for (size_t i = 0; i < child_count; ++i)
			sum += subset[i]->size();
		return sum;
	}
}
